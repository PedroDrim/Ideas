dateTime = as.numeric(dateTime)
dtTs = ts(valores, min(dateTime), max(dateTime))
dtTs = as.xts(dtTs)
if(key == keys[1]){
ts.list = dtTs
}else{
ts.list = merge(ts.list,dtTs)
}
}
colnames(ts.list) = keys
}
return(ts.list)
}
ts.list
length(keys)
dygraph(ts.list, main = "Quadro de acoes", ylab = "Valor", xlab = "horario")
DygraphClass = R6Class("DygraphClass",
public = list(
#=================================================#
getPlot = function(keys, colname, rangemax, tabela){
ts.list = private$createTs(keys, colname, rangemax, tabela)
if(length(keys) == 0){
ts.list = ts()
}
dygraph(ts.list, main = "Quadro de acoes", ylab = "Valor", xlab = "horario")
}
#=================================================#
),
private = list(
#=================================================#
createTs = function(keys, colname, rangemax, tabela.ini){
ts.list = c()
if(length(keys) > 0){
for(key in keys){
index = which(tabela.ini$symbol == key)
tabela = tabela.ini[index]
inicio = 1
tamanho = dim(tabela)[1]
if(tamanho > rangemax){
inicio = tamanho - rangemax
}
tabela = tabela[inicio:tamanho]
valores = tabela[,colname, with = F]
valores = unlist(valores)
valores = as.numeric(valores)
valor.maximo = max(valores)
valor.minimo = min(valores)
if(valor.maximo > valor.minimo * 100){
valor.media = mean(valores[valores != valor.maximo])
valores[valores == valor.maximo] = valor.media
}
dateTime = strptime(tabela$queryDateTime, "%Y-%m-%d %H:%M:%S")
dateTime = as.numeric(dateTime)
dtTs = ts(valores, min(dateTime), max(dateTime))
dtTs = as.xts(dtTs)
if(key == keys[1]){
ts.list = dtTs
}else{
ts.list = merge(ts.list,dtTs)
}
}
colnames(ts.list) = keys
}
return(ts.list)
}
#=================================================#
)
)
dygraphObject = DygraphClass$new()
keys = c("YHOO","AAPL")
coln = 20
coln = "Ask"
rangemax = 20
dygraphObject$getPlot(keys, coln, rangemax, tabela)
valor.maximo
tabela
inicio
tamanho
key
keys = c("YHOO","GOOG")
tabela.ini
dygraphObject$getPlot(keys, coln, rangemax, tabela.ini)
install.packages("RSQLite")
library("RSQLite", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.0")
con = dbConnect(drv="SQLite", dbname="country.sqlite")
PersistenceClass = R6Class("PersistenceClass",
public = list(
#=================================================#
initialize = function(fileName){
private$fileName = fileName
},
#=================================================#
#=================================================#
serializeTable = function(tabela, FIRST = T){
write.table(tabela, private$fileName, row.names = F,
append = !FIRST, col.names = FIRST, sep =  ";")
},
#=================================================#
#=================================================#
deserializeTable = function(){
return(fread(private$fileName))
},
#=================================================#
#=================================================#
destroyTable = function(){
unlink(private$fileName)
}
#=================================================#
),
private = list(
private$fileName = c()
)
)
PersistenceClass = R6Class("PersistenceClass",
public = list(
#=================================================#
initialize = function(fileName){
private$fileName = fileName
},
#=================================================#
#=================================================#
serializeTable = function(tabela, FIRST = T){
write.table(tabela, private$fileName, row.names = F,
append = !FIRST, col.names = FIRST, sep =  ";")
},
#=================================================#
#=================================================#
deserializeTable = function(){
return(fread(private$fileName))
},
#=================================================#
#=================================================#
destroyTable = function(){
unlink(private$fileName)
}
#=================================================#
),
private = list(
fileName = c()
)
)
require(R6)
PersistenceClass = R6Class("PersistenceClass",
public = list(
#=================================================#
initialize = function(fileName){
private$fileName = fileName
},
#=================================================#
#=================================================#
serializeTable = function(tabela, FIRST = T){
write.table(tabela, private$fileName, row.names = F,
append = !FIRST, col.names = FIRST, sep =  ";")
},
#=================================================#
#=================================================#
deserializeTable = function(){
return(fread(private$fileName))
},
#=================================================#
#=================================================#
destroyTable = function(){
unlink(private$fileName)
}
#=================================================#
),
private = list(
fileName = c()
)
)
# http://www.investopedia.com/terms/b/bid-and-asked.asp
# https://www.google.com/finance?q=OTCMKTS%3ASSNNF&ei=AA8mWNn0FeSDiQLn3rl4
RequestClass = R6Class("RequestClass",
public = list(
#=================================================#
getValues.now = function(keys){
keys_string = paste0(keys, collapse = "','")
base = "https://query.yahooapis.com/v1/public/yql?"
query = sprintf("q=select symbol,Name,Currency,Bid,Ask,PercentChange from yahoo.finance.quotes where symbol in ('%s')&",keys_string)
format = "format=json&env=store%3A%2F%2Fdatatables.org%2Falltableswithkeys&callback="
yql = paste0(base, query, format)
action.table = private$getTable(yql)
action.table = action.table[,c(1,4,3,2,6,5,7), with = F]
action.table$type = "observed"
return(action.table)
},
#=================================================#
#=================================================#
getValues.historical = function(keys, dataInicio, dataFim){
dataInicio = as.character(dataInicio)
dataFim = as.character(dataFim)
keys_string = paste0(keys, collapse = "','")
base = "https://query.yahooapis.com/v1/public/yql?"
query = sprintf("q=select * from yahoo.finance.historicaldata where symbol in ('%s') and startDate = '%s' and endDate = '%s'&",keys_string ,dataInicio, dataFim)
format = "format=json&env=store%3A%2F%2Fdatatables.org%2Falltableswithkeys&callback="
yql = paste0(base, query, format)
historical.table = private$getTable(yql)
historical.table$type = "observed"
return(historical.table)
}
#==================================================#
),
private = list(
#=================================================#
getTable = function(yql, queryDateTime = T){
yql = gsub(" ","%20",yql)
jsonResp = fromJSON(yql)
table = jsonResp$query$results$quote
table = as.data.table(table)
if(queryDateTime){
queryDateTime = jsonResp$query$created
queryDateTime = gsub("Z", "", queryDateTime)
queryDateTime = gsub("T", " ", queryDateTime)
table$queryDateTime = queryDateTime
}
return(table)
}
#=================================================#
)
)
persistenceObject = PersistenceClass$new(arquivo)
arquivo = "teste.csv"
persistenceObject = PersistenceClass$new(arquivo)
requestObject = RequestClass$new()
tabela = requestObject$getValues.now()
keys = c("YHOO","AAPL", "GOOG")
tabela = requestObject$getValues.now(keys)
require(curl)
require(neuralnet)
require(jsonlite)
require(data.table)
require(R6)
require(dygraphs)
require(xts)
gc()
tabela = requestObject$getValues.now(keys)
View(tabela)
persistenceObject$serializeTable(tabela)
NeuralClass = R6Class("NeuralClass",
public = list(
#=================================================#
initialize = function(tabelaEntrada){
private$tabelaEntrada = tabelaEntrada
private$keys.data = unique(tabelaEntrada$symbol)
private$list.netLearning = length(private$keys.data)
private$training()
},
#=================================================#
#=================================================#
use = function(dateTimeInicial, dateTimeFinal, key){
dateTimeInicial = strptime(dateTimeInicial, "%Y-%m-%d %H:%M:%S")
dateTimeFinal = strptime(dateTimeFinal, "%Y-%m-%d %H:%M:%S")
startTime = dateTimeInicial
dateTimeInicial = as.numeric(dateTimeInicial)
dateTimeFinal = as.numeric(dateTimeFinal)
intervalo = seq(dateTimeInicial, dateTimeFinal, by = 60)
net.result = attr(private$list.netLearning,key)
net.get = compute(net.result, intervalo)$net.result
net.get = round(net.get,digits = 3)
dateFormatInterval = startTime + 60*(0: (length(intervalo)-1) )
tabelaEsperada = data.table(symbol = key, Bid = net.get[,1], Ask = net.get[,2],
queryDateTime = dateFormatInterval, type = "simulated")
tabelaEntrada = private$tabelaEntrada
tabelaEntrada = tabelaEntrada[,c(1,2,3), with = F]
tabelaEntrada = unique(tabelaEntrada)
setkey(tabelaEsperada,symbol)
setkey(tabelaEntrada, symbol)
tabelaEsperada = merge(tabelaEntrada,tabelaEsperada)
tabelaEsperada$PercentChange = "---"
tabelaEsperada = tabelaEsperada[, c(1,2,3,4,5,8,6,7), with = F]
return(tabelaEsperada)
}
#=================================================#
),
private = list(
#=================================================#
keys.data = c(),
tabelaEntrada = data.table(),
list.netLearning = 0,
#=================================================#
#=================================================#
training = function(){
ids = private$keys.data
tabela = private$tabelaEntrada
tabela = tabela[,c(1,7,4,5), with = F]
for(id in ids){
index = which(tabela$symbol == id)
result.key = tabela[index]
result.key$symbol = NULL
qdt = strptime(result.key$queryDateTime, "%Y-%m-%d %H:%M:%S")
result.key$queryDateTime = as.numeric(qdt)
result.key = mapply(as.numeric, result.key)
net.result = neuralnet(Bid+Ask~queryDateTime,  result.key, hidden=15, threshold=0.001)
attr(private$list.netLearning, id) = net.result
}
}
#=================================================#
)
)
quantidade = 10
Sys.sleep(2)
persistenceObject = PersistenceClass$new(arquivo)
requestObject = RequestClass$new()
for(i in 1:quantidade){
first = (i == 1)
tabela = requestObject$getValues.now(keys)
persistenceObject$serializeTable(tabela)
Sys.sleep(5)
}
PersistenceClass = R6Class("PersistenceClass",
public = list(
#=================================================#
initialize = function(fileName){
private$fileName = fileName
},
#=================================================#
#=================================================#
serializeTable = function(tabela, FIRST = T){
write.table(tabela, private$fileName, row.names = F,
append = FIRST, col.names = !FIRST, sep =  ";")
},
#=================================================#
#=================================================#
deserializeTable = function(){
return(fread(private$fileName))
},
#=================================================#
#=================================================#
destroyTable = function(){
unlink(private$fileName)
}
#=================================================#
),
private = list(
fileName = c()
)
)
persistenceObject = PersistenceClass$new(arquivo)
requestObject = RequestClass$new()
for(i in 1:quantidade){
first = (i == 1)
tabela = requestObject$getValues.now(keys)
persistenceObject$serializeTable(tabela)
Sys.sleep(5)
}
neuralParam = 20
PersistenceClass = R6Class("PersistenceClass",
public = list(
#=================================================#
initialize = function(fileName){
private$fileName = fileName
},
#=================================================#
#=================================================#
serializeTable = function(tabela, FIRST = T){
write.table(tabela, private$fileName, row.names = F,
append = !FIRST, col.names = FIRST, sep =  ";")
},
#=================================================#
#=================================================#
deserializeTable = function(){
return(fread(private$fileName))
},
#=================================================#
#=================================================#
destroyTable = function(){
unlink(private$fileName)
}
#=================================================#
),
private = list(
fileName = c()
)
)
persistenceObject = PersistenceClass$new(arquivo)
requestObject = RequestClass$new()
for(i in 1:quantidade){
first = (i == 1)
tabela = requestObject$getValues.now(keys)
persistenceObject$serializeTable(tabela, first)
Sys.sleep(5)
}
tabelaFinal = persistenceObject$deserializeTable()
View(tabelaFinal)
key = keys[1]
neuralObject = NeuralClass$new(tabelaFinal)
View(tabelaFinal)
tabelaFinal.short = tabelaFinal[, c(1,7), with = F]
tabelaFinal.short = tabelaFinal[c(1,2,3), c(1,7), with = F]
tabelaFinal.short
index = which(tabelaFinal$symbol == key)
tabelaFinal.short = tabelaFinal[index, c(1,7), with = F]
View(tabelaFinal.short)
qdt = strptime(tabelaFinal.short$queryDateTime, "%Y-%m-%d %H:%M:%S")
dateTimeInicial = max(qdt)
as.character(max(qdt))
dateTimeInicial = as.character(max(qdt))
dateTimeInicial = max(qdt)
extrapolatedMinute = 20
(extrapolatedMinute * 20)
dateTimeInicial = max(qdt)
dateTimeFinal = dateTimeInicial + (extrapolatedMinute * 20)
dateTimeInicial
dateTimeFinal
dateTimeFinal = dateTimeInicial + (extrapolatedMinute * 60)
dateTimeFinal
dateTimeInicial = as.character(dateTimeInicial)
dateTimeFinal = as.character(dateTimeFinal)
neuralObject$use(key, dateTimeInicial, dateTimeFinal)
key
neuralObject$use(dateTimeInicial, dateTimeFinal, key)
qdt = strptime(tabelaFinal.short$queryDateTime, "%Y-%m-%d %H:%M:%S")
dateTimeInicial = max(qdt) + 60
dateTimeFinal = dateTimeInicial + (extrapolatedMinute * 60)
dateTimeInicial = as.character(dateTimeInicial)
dateTimeFinal = as.character(dateTimeFinal)
x = neuralObject$use(dateTimeInicial, dateTimeFinal, key)
View(x)
View(tabelaFinal)
dataSimulated = neuralObject$use(dateTimeInicial, dateTimeFinal, key)
rbind(tabelaFinal, dataSimulated)
View(dataSimulated)
str(dataSimulated)
dataSimulated$queryDateTime = as.character(dataSimulated$queryDateTime)
rbind(tabelaFinal, dataSimulated)
tabelaFinal = rbind(tabelaFinal, dataSimulated)
#==========================================================#
load.datas = function(){
require(curl)
require(neuralnet)
require(jsonlite)
require(data.table)
require(R6)
require(dygraphs)
require(xts)
arquivos = list.files("src",full.names = T)
status = sapply(arquivos, source)
gc()
}
#==========================================================#
#==========================================================#
create.InitialSequence = function(keys, arquivo, quantidade, extrapolatedMinute = 0){
persistenceObject = PersistenceClass$new(arquivo)
requestObject = RequestClass$new()
for(i in 1:quantidade){
first = (i == 1)
tabela = requestObject$getValues.now(keys)
persistenceObject$serializeTable(tabela, first)
Sys.sleep(5)
}
tabelaFinal = persistenceObject$deserializeTable()
if(extrapolatedMinute > 0){
neuralObject = NeuralClass$new(tabelaFinal)
for(key in keys){
index = which(tabelaFinal$symbol == key)
tabelaFinal.short = tabelaFinal[index, c(1,7), with = F]
qdt = strptime(tabelaFinal.short$queryDateTime, "%Y-%m-%d %H:%M:%S")
dateTimeInicial = max(qdt) + 60
dateTimeFinal = dateTimeInicial + (extrapolatedMinute * 60)
dateTimeInicial = as.character(dateTimeInicial)
dateTimeFinal = as.character(dateTimeFinal)
dataSimulated = neuralObject$use(dateTimeInicial, dateTimeFinal, key)
dataSimulated$queryDateTime = as.character(dataSimulated$queryDateTime)
tabelaFinal = rbind(tabelaFinal, dataSimulated)
}
}
return(tabelaFinal)
}
#==========================================================#
#==========================================================#
load.datas = function(){
require(curl)
require(neuralnet)
require(jsonlite)
require(data.table)
require(R6)
require(dygraphs)
require(xts)
arquivos = list.files("src",full.names = T)
status = sapply(arquivos, source)
gc()
}
#==========================================================#
#==========================================================#
create.InitialSequence = function(keys, arquivo, quantidade, extrapolatedMinute = 0){
persistenceObject = PersistenceClass$new(arquivo)
requestObject = RequestClass$new()
for(i in 1:quantidade){
first = (i == 1)
tabela = requestObject$getValues.now(keys)
persistenceObject$serializeTable(tabela, first)
Sys.sleep(5)
}
tabelaFinal = persistenceObject$deserializeTable()
if(extrapolatedMinute > 0){
neuralObject = NeuralClass$new(tabelaFinal)
for(key in keys){
index = which(tabelaFinal$symbol == key)
tabelaFinal.short = tabelaFinal[index, c(1,7), with = F]
qdt = strptime(tabelaFinal.short$queryDateTime, "%Y-%m-%d %H:%M:%S")
dateTimeInicial = max(qdt) + 60
dateTimeFinal = dateTimeInicial + (extrapolatedMinute * 60)
dateTimeInicial = as.character(dateTimeInicial)
dateTimeFinal = as.character(dateTimeFinal)
dataSimulated = neuralObject$use(dateTimeInicial, dateTimeFinal, key)
dataSimulated$queryDateTime = as.character(dataSimulated$queryDateTime)
persistenceObject$serializeTable(dataSimulated, F)
}
}
}
#==========================================================#
#load.datas()
